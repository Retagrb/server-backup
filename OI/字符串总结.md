# 字符串总结

这已经是我总结的第六个板块的知识点了。

现在回过头来再看最开始整理的[线段树总结](https://www.cnblogs.com/xrkforces/p/Segment-tree.html)，感觉那个时候的我好傻逼。整个整理完全都是混乱不清的，没有条理，啰啰嗦嗦，叙述不清晰，甚至现在去看那些东西都有可能看不懂。

到了图论部分，就已经很系统和完整了，感觉不管怎么说，自己还是在进步吧。

---

## 字符串哈希

### 定义

将输入的字符串转化为整数，映射到一个值域较小，可以方便比较的范围内。

把自己串转化为整数的函数 $f$ 称作**哈希函数**。

### 做法

- 单模数
  
  取一固定质数 $P$，把字符串看作 $P$ 进制数，并分配一个大于 0 的数值，代表每种字符。
  
  取一固定模数 $mod$，求出该 $P$ 进制数对 $mod$ 的余数，作为该字符串的哈希值。

- 双模数
  
  只是将上面的一个 $P$ 和 $mod$ 改成两个即可。存储时可以用 $set$ 存储到一个 $pair$ 里面。

- 自然溢出
  
  采用 $unsigned$ $long$ $long$ 存储这个 Hash 值，而不需要固定模数 $mod$。相当于 $mod= 2^{64}-1$。

一般来讲我们选用的 $P=29,31$，$mod=1e9+7,998244353$。

自然溢出和取模运算都是常见的字符串哈希的处理技巧。（其实不光是字符串哈希，还有其它很多处理大数的时候）

自然溢出巧妙地利用了 ull 的运算机制，避免了低效的取模运算：对于超出 ull 范围限制的，进位，然后只保留在 ull 范围限制位数内的数，相当于是在原数的基础上 $\%2^{64}−1$。

取模运算是直接对原数进行取模，相对于自然溢出，冲突的概率偏大，因为自然溢出对应的值域是用 $1e9$ 模数的几十亿倍多。细节偏多。常用双模数来降低冲突概率。

### 求解

如果我们已知字符串 $S$ 的哈希值是 $Hash(S)$，那么在 $S$ 后面添加一个字符 $c$ 后构成的新字符串 $S+c$ 的哈希值就为 $Hash(S+c)=(Hash(S)+P+v_c)\% mod$。其中 $v_c$ 是 $c$ 字符串的值。

### 拓展——差分意义下的字符串哈希

上面我们求解的相当于是对于字符串 $S[0 \cdots s.size()-1]$ 的哈希值。那么如何求解字符串 $S[l \cdots r]$ 的哈希值呢？

可以借鉴在学习前缀和与差分时的思想，可以得到：

$$
Hash_{S[l \cdots r]} =( Hash_{S[0 \cdots r]}-Hash_{S[0 \cdots l-1]} \times P^{r-l+1})\% mod
$$

注意：在具体的代码实现中，由于括号中的值可能为负，我们需要进行**负数维护**，具体详见下方代码。

### 代码实现

```cpp
//这里均以双模数为例子进行代码实现。
//一般意义下的字符串哈希：hash[1-s.size()]
#define mk make_pair
pair<int,int> gethash(const string &s)
{
    int hash1=0,hash2=0;
    for(int i=0;i<s.size();i++)
    {
        hash1=(hash1*P1+s[i])%mod1;
        hash2=(hash2*P2+s[i])%mod2;
    }
    return mk(hash1,hash2);
}
//差分意义下的字符串哈希：hash[l,r]
void init(const string &s)
{
    Pow1[0]=1;Pow2[0]=1;
    for(int i=1;i<=2000;i++)Pow1[i]=Pow1[i-1]*P1%mod1,Pow2[i]=Pow2[i-1]*P2%mod2;//这里别忘了% mod
    for(int i=0;i<s.size();i++)
    {
        hash1[i+1]=(hash1[i]*P1+(s[i]-'a'+1))%mod1;
        hash2[i+1]=(hash2[i]*P2+(s[i]-'a'+1))%mod2;
    }
}
pair<int,int> gethash(int l,int r)
{
    int sum1=(hash1[r]-hash1[l-1]*Pow1[r-l+1]%mod1+mod1)%mod1;
    int sum2=(hash2[r]-hash2[l-1]*Pow2[r-l+1]%mod2+mod2)%mod2;
    return mk(sum1,sum2);
}
```

## 字典树（Trie）

### 定义

字典树是一种用于实现字符串快速检索的多叉树结构。

## Z 函数（exkmp）

## manacher 算法

## AC 自动机

### 定义

**自动机**
