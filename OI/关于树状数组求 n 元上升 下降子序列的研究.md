# 关于树状数组求 n 元上升/下降子序列的研究

先挂 5 个题目链接：

[P1908 逆序对](https://www.luogu.com.cn/problem/P1908)

[P1637 三元上升子序列](https://www.luogu.com.cn/problem/P1637)

[楼兰图腾](https://www.acwing.com/problem/content/243/)

[CF597C Subsequences](https://www.luogu.com.cn/problem/CF597C)

[UVA12983 The Battle of Chibi](https://www.luogu.com.cn/problem/UVA12983)

不得不说 OI 真的是个很神奇的东西，从刚开始一个小的模型衍生出许许多多奇特的想法，再出了很多有趣的题目。

首先我们看逆序对。

相信只要是学过树状数组的同学都一定有所接触。

怎么用树状数组维护逆序对呢？

我们用树状数组维护每个数值 val 在集合 $a$ 中出现的次数。那么数组 $t$ 在 [l,r] 上的区间和（即 $\sum_{i=1}^{r} t[i]$ ）表示集合 $a $ 中范围在 [l,r] 内的数有几个。

怎么想到这里的呢？

我们接着往下走。

我们可以把原序列倒着扫一遍，对于每个当前数 a[i]:

1. 在树状数组上查询前缀和 [1,a[i]-1]，累加到答案 $ans$ 中；

2. 执行“单点修改”操作，把位置 a[i] 上的数 +1。那么最后的 $ans$ 即为所求。

到这里我们就可以弄清楚“怎么想到”这个问题了。

假如我们之前就打算把原序列倒着扫一遍然后对每个当前数 a[i] 执行操作，我们一定会想到去给位置 $a[i]$ 上的数加一。

那么我们就可以很容易的想到去使用树状数组来维护。

逆序对的问题就这样解决了。

一般地，通过逆序对也对我们做题目有所启发，启发我们在题目中可以考虑使用树状数组来维护一个值在一个集合中出现的次数。没准，就是个突破口呢。

看第二道题目——三元上升子序列。

看到题目，我们可以发现，其实这道题目和逆序对有很多的条件和要求是相似的：

1. 相对于此题，逆序对从某种意义上可以看做是**二元下降序列**，而此题是**三元上升序列**。也就是说，前者是满足 $a_i>a_j$ 且 $i<j$ ;而后者是 $a_i<a_j<a_k$ 且 $i<j<k$ 。

2. 逆序对那道题目是求逆序对的个数；而这道题目也是求三元上升序列的个数。

题目条件要求上的相似点和不同点对应着解法上的异同点：

**相同点**：

1. 我们同样可以采用树状数组来维护值 val 在集合 $a$ 中出现的次数。

2. 在求答案 $ans$  的时候同样可以使用前缀和讲答案累计到 $ans$ 中去；

**不同点**：

1. 由于逆序对是二元，而这道题目是三元，所以在使用树状数组求前缀和时，我们应该用两个数组：lef和rit类分别表示 a[i] 左边和右边大于和小于 a[i] 的元素个数。然后枚举中间元素 a[i] ;

2. 由于两个数组一个是枚举大于 a[i] 的元素而一个是小于，所以循环两遍，一遍正序，一遍倒序。

3. 另外要注意的一点是在求 rit 数组的时候的写法：rit[i]=n-i-(ask(a[i]-1));

4. 最后答案是 $\sum_{i=1}^{N} lef[i]*rit[i]$。

到这里，三元上升子序列的问题就完美解决！

楼兰图腾那道题，是我从蓝书上看到，和三元上升子序列几乎一样的题目。稍微有点不同的是：这道题的条件是 $x_1<x_2<x_3$ ，$y_1>y_2$ 且 $y_3>y_2$ 的“v 型序列”和另一种“^型序列”。所以基本的思路实际上是一样的，只不过 lef 和 rit 表示的是左边和右边**都比它大或者小**的数。

接下来我们再继续做一个拓展延伸：

刚刚我们研究的是**二元逆序对**和**三元上升子序列**，那么我们自然而言就要想了，这一类的问题，我们是否可以拓展到 $n$ 元去呢？

_善于探索的精神总是可贵的，不管我们是否能探索出来或者所进行的探索是否有效。_

我们先想想能不能沿用在逆序对和三元上升子序列的做法。

如果我们再去像这两个题一样，去枚举每个点为**中间点**，然后再分别求左边和右边比它大或者小的数，那么我们似乎要循环很多次，而且似乎细节非常多，是不可行的。

那么怎么办呢？

想一想，我们要求的是“N 元上升子序列”，看到“上升子序列”，你是否联想到什么呢？

我们在初学 DP 的时候，学到了一个叫做“最长上升子序列”的问题。我们当时求解这个问题的时候，是用状态 $dp[i]$ 表示以 $a[i]$ 结尾的最长上升子序列。转移方程：$dp[i]=\max_{0 \le j \le i,a[j]<a[i]}(dp[j]+1)$ 。

那么我们同样可以设计一个转移状态来求解此题：

$dp[i][j]$ 表示以 $a[j]$ 结尾的 $n$ 元上升子序列的个数。转移方程：$dp[i][j]=\sum_{0<k<j,a[k]<a[j]}dp[i-1][k]$ （注意这里是求和不是取max）。

分析一下时间复杂度：$O(n^3)$ 。

显然会 T，考虑优化。外面两层的枚举 $i$ 和 $j$ 都不能再优化，那么只能在最内层枚举 $k$ 这里优化。

再回归到树状数组。我们可以建立一个树状数组，以 $a[k]$ 为下标维护 $dp[i-1][k]$ 的值，到了最内层循环，类比逆序对的做法，直接 $dp[i][j]=ask(a[j]-1)$，然后 $add(a[j],dp[i-1][j])$ ，最后的答案就是 $\sum_{i=1}^{n}dp[n][i]$ 。

这种做法的正确性保证在于，通过从小到大的枚举，保证了 $k<j$ ，通过查询 $dp[i-1][j-1]$ 的前缀和保证了 $a[k]<a[j]$ 。

至此，我们通过优化，在 $\log n$ 的时间复杂度内完美地解决了最后一层循环的问题。

总时间复杂度：$O(n^2 \log n)$。

到这里，我们就完整地使用树状数组优化 DP 的办法解决了“N 元上升/下降序列”的问题。

### 总结

“N元上升/下降子序列”最开始的模型是**逆序对**和**最长上升子序列**。应该说，它是这两者的结合体。从问题特征上的结合，同样也带来了解法上的结合：用树状数组优化 DP。

我们解决这个问题，是从最基本的逆序对（二元下降序列）开始的，然后从二元拓展到三元，再联想到 N 元。从下降序列联想到上升序列，甚至类比到像楼兰图腾那样的“V型”“^型”序列。

果然，OI 问题的解决，总要有很强的思维能力，联想能力和好奇心。

**我想，不仅仅是 OI，还有其它理科问题，甚至生活中的问题之间，其实都有着千丝万缕的联系，从一到二，二到三，三到万物，大概就是这个原理吧。只要我们时时刻刻保持着对生活的好奇心，我们就会一直进步，一直发现生活的乐趣，学习的乐趣。**
