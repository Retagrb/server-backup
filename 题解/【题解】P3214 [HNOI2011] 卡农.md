# 【题解】P3214 [HNOI2011] 卡农

这是我几天前就跟自己说，要把这道题作为我的首黑，结果 4.18 的时候 A 了一道紫题加强版的黑……于是这题就变成了第二道黑。不过也算是自己给自己的生日礼物了吧。

---

## 题目链接

[P3214 [HNOI2011] 卡农](https://www.luogu.com.cn/problem/P3214)

## 思路分析

第一步，需要转化题意（~~吐槽一下：个人觉得出题人语文没学好~~）：

相当于是在 $S=\{1,2,3,\cdots,n\}$ 这个集合中选出 $m$ 个子集，满足以下三条性质：

1. 子集不空；

2. 没有相同的子集（不重复）；

3. 在所有的子集中，1-n 每个元素出现的次数是偶数；

其实这个题的 $DP$ 可以说是最容易想到的（然而我当时不知道为啥就是没想到）。

用 $dp_i$ 表示已经考虑到了第 $i$ 个子集，满足上述三个条件的方案数有多少个。

考虑 $dp_i$ 如何计算。

要使得满足以上三个条件。那么可以很容易想到容斥原理，关键是怎么容斥。

根据容斥原理：**总方案数-不合法方案数**。

所以我们要做的无非就是找到题目中对应的**总方案数**和**不合法方案数**分别是什么。

首先，我们可以想到用其中一个条件的方案数作为总的方案数，然后减去另外两个条件对应的不合法方案数。

可以发现，计算条件 3 的不合法方案数时，似乎非常不好算。（反正我是想不到怎么算）。

那么我们不妨用条件 3 的方案数作为总方案数，然后减去不满足条件 1 的方案数，再减去不满足条件 2 的方案数。

对于 $dp_i$，我们将以上三者分别考虑。

- **满足条件 3 的总方案数**
  
  首先可以发现，条件 3 的"$1-n$ 每个元素出现偶数次"实际上可以转化为：选出来的 $i$ 个子集的**异或和为 0**。那么当前 $i-1$ 个子集确定，最后一个子集也就唯一确定了。
  
  所以答案就是 $\mathrm A_{2^n-1}^{i-1}$。

- **不满足条件 1 的方案数**
  
  条件 1 中“子集非空”的反义是“子集是空集”，所以不满足条件 1 的方案数就是子集是空集的方案数。要使得第 $i$ 个子集为空，那么前 $i-1$ 个子集已经满足上述三个条件。
  
  所以答案就是 $dp_{i-1}$。

- **不满足条件 2 的方案数**
  
  对于条件 2，当第 $i$ 个子集与前面某个自己（设为 $j$）重复时，那么就说明前 $i-2$ 个子集已经满足上述三个条件，也就是 $dp_{i-2}$。
  
  然后考虑 $i$ 和 $j$。
  
  显然 $j$ 有 $i-1$ 种可能，那么 $i$ 有 $2^n-1-(i-2)$ 种取法。
  
  所以根据**乘法原理**，不满足条件 2 的总方案数有 $dp_{i-2} \times (i-1) \times (2^n-i+1)$。

综上，根据**加法原理**，我们有：

$$
dp_i=A_{2^n-1}^{i-1}-dp_{i-1}-dp_{i-2} \times (i-1) \times (2^n-i+1)
$$

最后结果就是 $dp_m$。

**最后一点（不要忘了）：由于题目要求的是无序，所以结果除以 $m!$。**

## 坑点

1. 提前把**排列数**预处理出来，不要线性求逆元然后用乘法逆元求**排列数**，因为 $2^n$ 可能很大，你数组不一定存的下它的阶乘。

2. 求逆元不要用线性求逆元，$m!$ 可能很大，线性求逆元你存都存不下，直接用费马小定理求 $m! \bmod (mod-2)$ 就好了。

3. 开 long long，并且记得每次计算完之后都 （+mod）%mod 一下，否则可能会出现负数（dbxxx就挂在这里了）。

## 代码实现

```cpp
//luoguP3214
#include<iostream>
#include<cstdio>
#define int long long
using namespace std;
const int mod=1e8+7;
const int maxn=1e6+10;
int n,m;
int a[maxn];
int dp[maxn];

inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
    return x*f; 
}

int qpow(int a,int T)
{
    int ret=1;
    while(T)
    {
        if(T&1)(ret*=a)%=mod;
        (a*=a)%=mod;T>>=1;
    }
    return ret;
}

int in(int x)// x 的阶乘
{
    int ans=1;
    for(int i=1;i<=x;i++)(ans*=i)%=mod;
    return ans;
}

signed main()
{
    n=read();m=read();
    int t=qpow(2,n)-1;
    a[0]=1;
    for(int i=1;i<=m;i++)a[i]=a[i-1]*(t-i+1+mod)%mod;//预处理 A
    dp[1]=0;dp[0]=1;
    for(int i=2;i<=m;i++)
    {
        dp[i]=((a[i-1]-dp[i-1]+mod)%mod-dp[i-2]*(i-1)%mod*(t-(i-2)+mod)%mod+mod)%mod;//记得多 % 几遍。
        dp[i]=(dp[i]+mod)%mod;
    }
    cout<<dp[m]*qpow(in(m),mod-2)%mod<<endl;//除以 m!（先求出 m!%mod 意义下的逆元，再用dp[m]乘上这个逆元。
    return 0;
}
```
