# ABC 299 F

我们用 $σ(i,c)$ 表示小写英文字母 $c$ 在第 $i$ 个及之后字符 $S[i+1], S[i+2], ..., S[N]$ 中出现的最左位置。如果第 $i$ 个及之后字符中不包含 $c$，则我们将 $σ(i,c)$ 定义为 $∞$。

这个问题要求找到表示为字符串 $T$ 的 $TT$ 的（不同的）非空子序列 $T$ 的数量。

如样例输入 2 中所述，从 $S$ 中提取字符串可能有多种方式，因此我们需要避免多次计数相同的子序列。为了避免这种情况，我们实行以下规则：

>  （♠）：尽可能提取S的左侧字符。

换句话说，当我们从 $S$ 中提取子序列 $TT=T_1, T_2, ..., Tn, T_1, T_2, ..., T_n$ 时，我们首先关注 $TT$ 的第一个 $T$：

- 提取 $S$ 的第 $p_1$ 个字符，其中 $p_1=σ(0,T_1)$。
- 提取 $S$ 的第 $p_2$ 个字符，其中 $p_2=σ(p_1,T_2)$。
- 提取 $S$ 的第 $p_3$ 个字符，其中 $p_3=σ(p_2,T_3)$。 
- $\cdots$
- 提取 $S$ 的第 $p_n$ 个字符，其中 $p_n=σ(p_{n-1},T_n)$。

然后我们关注 $TT$ 的第二个 $T$：

- 提取 $S$ 的第 $q_1$ 个字符，其中 $q_1=σ(p_n,T_1)$。
- 提取 $S$ 的第 $q_2$ 个字符，其中 $q_2=σ(q_1,T_2)$。
- 提取 $S$ 的第 $q_3$ 个字符，其中 $q_3=σ(q_2,T_3)$。
- $\cdots$
- 提取 $S$ 的第 $q_n$ 个字符，其中 $q_n=σ(q_{n-1},T_n)$。

这个规则唯一地确定了从每个 $S$ 的子串提取子序列的方法，因此每个子序列 $T$ 都可以计算而没有重复计数。具体而言，我们尝试对每个固定的整数 $x$ 计算以下数量：

>  （⋆）：从 $S$ 中提取 $TT$ 的子序列数，使得 $q_1=x$，遵循规则（♠）。

通过对所有可能的位置 $x$ 求和 $(⋆)$，我们可以得到所需的结果。

对于一个固定的$q_1=x$，我们从$p_1=\sigma(0,T_1)=\sigma(0,S_x)$的位置开始，按照上述规则依次确定TT的第2个及之后的字符，同时从$q_1=x$的位置开始沿着规则（♠）抽取 TT的第二半部分。具体来说：

首先确定T的第二个字符$T_2$是哪个小写英文字母。设$p_2=\sigma(p_1,T_2)$，$q_2=\sigma(q_1,T_2)$，然后抽取S的$p_2$和$q_2$位置的字符。

然后确定$T_3$是哪个小写英文字母。设$p_3=\sigma(p_2,T_3)$，$q_3=\sigma(q_2,T_3)$，然后抽取S的$p_3$和$q_3$位置的字符。

以此类推，直到确定$T_n$是哪个小写英文字母。设$pn=\sigma(p_{n-1},T_n)$，$qn=\sigma(q_{n-1},T_n)$，然后抽取S的$pn$和$qn$位置的字符。

为了计算$(\star)$，只需要计算满足$\sigma(p_n,T_1)=q_1$的字符串T的个数。这可以通过动态规划(DP)来计算。具体来说，定义DP表：
$$
dp[i][j]=满足 pn=i 且 qn=j 的T的个数
$$


然后对于每个$(i,j)$，进行以下 26 个转移：
$$
dp[σ(i,c)][σ(j,c)]←dp[σ(i,c)][σ(j,c)]+dp[i][j],
$$
这对应于选择$T_{n+1}$的情况。其中，我们忽略$\sigma(i,c)=\infty$或$\sigma(j,c)=\infty$的字符c。

最终$(\star)$的值为满足$\sigma(p_n,T_1)=q_1$的T的个数，即：
$$
∑σ(i,Sx​)=x∑_jdp[i][j].
$$


这个DP的时间复杂度是$O(N^2)$。对于所有可能的$q_1$的位置$x$（共$O(N)$种情况），计算上述值的和，总时间复杂度是$O(N^3)$。